#lang racket
(require math)

;;cadena-isomorfa? : String String -> Boolean
;; nota1: string-ref : regresa el carácter en la posición k de la cadena
(define (cadena-isomorfa? s1 s2)
    (if (not (= (string-length s1)(string-length s2))) #f
        (aux-cadena-iso s1 s2 '() '() 0)))

(define (aux-cadena-iso s1 s2 aux1 aux2 i)
  (if (= i (string-length s1))
      #t
      (let* ([char1 (string-ref s1 i)]
             [char2 (string-ref s2 i)]
             [relacion1 (assoc char1 aux1)]
             [relacion2 (assoc char2 aux2)])
        (if relacion1
            (if relacion2
                (if (equal? (cdr relacion1) char2)
                    (aux-cadena-iso s1 s2 relacion1 relacion2 ( + i 1))
                    #f)
                #f)
            (if relacion2
                #f
                (aux-cadena-iso s1 s2
                                (cons (cons char1 char2) aux1)
                                (cons (cons char2 char1) aux2)
                                (+ i 1)))))))
  
;;simulador-dado : number -> (listof number)
;; version en la que el número n está dentro del rango [1-6] y la lista se detiene cuando la simulacion cae en n
(define (simulador-dado n)
  (define num (+ 1 (random 6)))
  (if (not (= n num ))
      (cons num (simulador-dado n))
      (list num)))
;;version que se pide en la tarea
(define (simulador-dado-tarea n)
  (define dado (random 1 7))
  (if (>= dado n)
      (list dado)
      (cons dado (simulador-dado-tarea (- n dado)))))
              
;; generate-brackets : number -> (listof string)
(define (generate-brackets n)
  (generate-brackets-helper n n "")) ;

;; generate-brackets-helper : number number string -> (listof string)
(define (generate-brackets-helper izq der str)
  (cond
    [(and (= izq 0) (= der 0)) (list str)] ; 
    [else
     (append
      (if (> izq 0)
          (generate-brackets-helper (- izq 1) der (string-append str "(")) ; 
          '())
      (if (> der izq)
          (generate-brackets-helper izq (- der 1) (string-append str ")")) ;
          '()))]))

;; contar-pasos-uno : number -> number
(define (contar-pasos-uno n)
  (define x 0)
  (cond
    [(= n 1) x]
    [else
     (define aux (if (= (modulo n 2) 0)
                     (/ n 2 )
                     (+ (* 3 n) 1)))
     (+ 1 (contar-pasos-uno aux))]))
               