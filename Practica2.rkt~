#lang racket

;; Funciones de orden superior y funciones an칩nimas.

(define (my-map f lst)
     (match lst
     [   '() lst]
     [(cons x xs) (cons (f x) (my-map f xs))]))

(define (my-foldr f v lst)
    (match lst
        [  '() v ]
        [(cons x xs) (f x (my-foldr f v xs ))]))

(define (my-foldl f v lst)
   (match lst
      [ '() v ]
      [(cons x xs ) (my-foldl f (f x v) xs)]))

;;  1. Una funcion que recibe una lista de numeros enteros lst y devuelve una lista
;;  de la representacion binaria de los numeros de lst

(define (binario-number n)
	(if (= n 0)
	'()
	(append (binario-number(quotient n 2)) (list (remainder n 2)))))

(define (a-binario lst)
   (my-map binario-number lst))

;; 2. Una funci 패on que recibe una lista de n 패umeros enteros lst y regresa una lista
;; con los numeros que son palindromos en lst.
(define (reverse-number n rev)
   (if (= n 0)
    rev
    (reverse-number (quotient n 10) (+ (* rev 10) (remainder n 10)))))

(define (palindromo? n)
    (= n (reverse-number n 0)))

(define(filter-palindromos lst)
  (filter palindromo? lst))


(struct carta (color valor) #:transparent)

;; 3. Define una estructura llamada juego que represente el estado del juego con
;; los campos:

(struct juego (mazo en-juego manos turno) #:transparent )

;; 4. Define un constructor crear-juego que inicialice el juego:
(define (generar-mazo)
  (shuffle
   (append
     (for*/list ([color '(rojo azul verde amarillo)] [valor (range 0 10)])
        (carta color valor))
     (for*/list ([color '(rojo azul verde amarillo)] [valor '( skip reverse draw-2 )])
        (carta color valor ))
     (for*/list ([valor '(wild draw-4)] [i (range 4)])
        ( carta 'especial valor )))))
         
(define (distribuir-cartas mazo num-jugadores)
  (define mazo-individual
    (for/list ([i (range num-jugadores)])  
      (take (drop mazo (* i 7)) 7))) 
  (define mazo-restante (drop mazo (* num-jugadores 7)))
  (values mazo-restante mazo-individual))

(define (crear-juego num-jugadores)
  (define mazo-inicial (generar-mazo))
  (define-values (mazo-restante mazo-individual)  (distribuir-cartas (cdr mazo-inicial) num-jugadores))
  (juego mazo-restante (car mazo-inicial) mazo-individual 0))

;; 5. Define una funcion jugar-carta que permita a un jugador jugar una carta
;; si es valida:
(define (jugar-carta juego indice-jugador carta)
  (let* ([mano (list-ref (juego-manos juego) indice-jugador)]
         [carta-en-juego (juego-en-juego juego)])
    (if (or (equal? (carta-color carta) (carta-color carta-en-juego))
            (equal? (carta-valor carta) (carta-valor carta-en-juego))
            (equal? (carta-color carta) 'especial))
        (let* ([nueva-mano (remove carta mano)]
               [nuevas-manos (list-set (juego-manos juego) indice-jugador nueva-mano)]
               [nuevo-turno (modulo (+ (juego-turno juego) 1) (length (juego-manos juego)))])
          (juego (juego-mazo juego) carta nuevas-manos nuevo-turno))
        (error "La carta no es valida"))))

;; 6. Una funcion que recibe una lista de n 패umeros lst enteros y devuelve un
;; numero entero que es la concatenacion de los elementos de la lista.

(define (concat-numero lst)
     (my-foldl(lambda(x enum) (+ x (* enum 10))) 0 lst))

;; 7. Define una funcion verificar-ganador que determine si un jugador se
;; quedo sin cartas en su mano.
(define (verificar-ganador manos [i 0])
  (cond
    [(empty? manos) #f]
    [(empty? (car manos)) i]
    [else (verificar-ganador (cdr manos) (add1 i))]))

  
